### Kotlin
- #### В чем разница между Java и Kotlin?
    - **Языковые особенности**: Kotlin предоставляет более современный синтаксис, поддерживает функциональное программирование, null-безопасность, extension functions, и множество других возможностей, которых нет в Java.
    - **Совместимость**: Kotlin полностью совместим с Java, позволяя использовать Java-библиотеки и фреймворки. В то же время, Kotlin предлагает более краткий и выразительный синтаксис.
    - **Компиляция**: Kotlin компилируется в байт-код JVM, как и Java, но также может компилироваться в JavaScript или в исполняемый код для платформы Android и iOS через Kotlin/Native.

- #### Каково преимущество использования `const` в Kotlin?
  `const` используется для определения компиляционных констант. Значения, объявленные как const, встраиваются непосредственно в код в места их использования, что улучшает производительность и уменьшает количество объектов во время выполнения.

- #### Когда использовать ключевое слово `lateinit` в Kotlin?
  `lateinit` используется для отложенной инициализации переменных, тип которых не может быть null. Это позволяет объявить переменную без начальной инициализации и инициализировать ее позже.

- #### Что такое inline функция в Kotlin?
  `Inline` функции встраивают код функции в место ее вызова, что уменьшает накладные расходы на вызов функций, особенно полезно для функций с лямбда-параметрами.

- #### Что такое companion object в Kotlin?
  `Companion object` позволяет объявить члены класса, доступные без создания экземпляра этого класса, аналогично статическим членам в Java.

- #### Удаление дубликатов из массива в Kotlin
  Для удаления дубликатов можно использовать distinct() или преобразовать массив в Set.

- #### Что такое аннотация `JvmStatic` в Kotlin?
  `@JvmStatic` используется в companion object для указания, что аннотированный член должен быть сгенерирован как статический метод в Java.

- #### Что такое аннотация `JvmField` в Kotlin?
  `@JvmField` предотвращает генерацию геттеров и сеттеров для переменной, делая ее публичным полем в Java.

- #### Что такое аннотация `JvmOverloads` в Kotlin?
  `@JvmOverloads` генерирует перегруженные версии функций для Java, предоставляя значения по умолчанию для параметров.

- #### `noinline` в Kotlin
  noinline используется для указания, что лямбда-параметр не должен инлайниться, например, если он передается в другую функцию как аргумент или сохраняется в переменной.
  ```kotlin
  inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) { }
  ```
- #### `crossinline` в Kotlin
  `crossinline` гарантирует, что лямбда-выражение не будет содержать нелокальных возвратов, то есть возвратов из внешней функции.
  ```kotlin
  inline fun withoutCrossinline(block: () -> Unit) {
    println("Before block")
    block() // Этот блок может содержать нелокальный return
    println("After block") // Этот код может быть пропущен, если в block() есть нелокальный return
  }

  inline fun withCrossinline(crossinline block: () -> Unit) {
    println("Before block")
    block() // Этот блок не может содержать нелокальный return из-за crossinline
    println("After block") // Этот код будет выполнен после block() независимо от содержимого block
  }

  fun main() {
    withoutCrossinline {
        println("Inside block")
        return // Нелокальный возврат: выходит из main(), не достигая "After block"
    }
    
    withCrossinline {
      println("Inside block")
      // return // Ошибка: нелокальные возвраты запрещены в лямбде с crossinline
    }
  }
  ```
- #### Функции области видимости в Kotlin
  Функции области видимости (`let`, `run`, `with`, `apply`, `also`) позволяют упростить работу с объектами, временно изменяя их контекст или обеспечивая дополнительную область видимости для выполнения кода.

- #### Что такое ключевое слово `reified` в Kotlin?
  `reified` используется с `inline` функциями для сохранения типов во время выполнения, позволяя работать с ними как с обычными классами, не теряя информацию о типе.
  ```kotlin
  inline fun <T> myGenericFunction(clazz: Class<T>, item: Any) {
    if (item is T) { // Ошибка: Cannot check for instance of erased type: T
        println("Item is of type T")
    }
  }
  
  inline fun <reified T> myGenericFunction(item: Any) {
    if (item is T) { // Теперь это работает, так как T является reified типом
        println("Item is of type T")
    }
  }
  ```

- #### `lateinit` против `lazy` в Kotlin
  lateinit используется для отложенной инициализации мутабельных переменных, а lazy - для иммутабельных переменных, инициализируемых при первом обращении.

- #### Что такое блок `init` в Kotlin?
  Инициализационный блок init используется для выполнения кода в момент создания экземпляра класса.

- #### Разница между `==` и `===` в Kotlin
  `==` проверяет равенство значений, в то время как `===` проверяет идентичность объектов (ссылаются ли переменные на один и тот же объект в памяти).

- #### Что такое функции высшего порядка в Kotlin?
  Функции высшего порядка - это функции, которые принимают функции в качестве параметров или возвращают их. Это позволяет создавать выразительный и гибкий код.

- #### Что такое Лямбды в Kotlin?
  Лямбда-выражения или лямбды - это короткие блоки кода, которые могут быть переданы в функции высшего порядка.

- #### `AssociateBy` - List to Map в Kotlin
  `associateBy` - это функция коллекций, которая создает `Map` из `List`, используя предоставленную функцию для определения ключей.

- #### Ключевое слово `Open` в Kotlin
  В Kotlin все классы по умолчанию закрыты (`final`) для наследования. Чтобы класс мог быть унаследован, он должен быть помечен как `open`.

- #### Модификатор видимости `internal` в Kotlin
  `internal` делает член класса видимым только внутри модуля, в котором он объявлен.

- #### `partition` - функция фильтрации в Kotlin
  `partition` разделяет коллекцию на пару списков по условию: один для элементов, соответствующих условию, и один для остальных.
  ```kotlin
  val (positives, negatives) = list.partition { it > 0 }
  ```

- #### `infix` в Kotlin
  `infix` позволяет вызывать функции с одним параметром без скобок и точки.
  ```kotlin
  infix fun Int.add(other: Int): Int = this + other
  val sum = 1 add 2
  ```

- #### Как работает Kotlin Multiplatform?
  Kotlin Multiplatform - это фреймворк, позволяющий разрабатывать кросс-платформенные приложения, используя Kotlin. Код, не зависящий от платформы, пишется один раз и может быть использован на разных платформах.

- #### Приостанавливающие vs Блокирующие функции в Kotlin Coroutines
    - Приостанавливающие функции (`suspend`) позволяют асинхронно выполнять длительные операции без блокирования потока.
    - Блокирующие операции заставляют поток ожидать завершения операции.

- #### Расскажите некоторые преимущества Kotlin.
  Kotlin предлагает безопасность по отношению к null, сокращенный и более читаемый синтаксис по сравнению с Java, поддержку функционального программирования, совместимость с Java, поддержку корутин для асинхронного программирования.

- #### В чем разница между `val` и `var`?
  `val` объявляет иммутабельную переменную (константу), значение которой не может быть изменено после инициализации. `var` объявляет мутабельную переменную, значение которой может быть изменено.

- #### Как проверить, инициализирована ли переменная `lateinit`?
  ```kotlin
  if (::name.isInitialized) {
    println(name)
  }
  ```

- #### Как выполнить ленивую инициализацию переменных в Kotlin?
  `lazy` предоставляет механизм ленивой инициализации для `val`, когда значение инициализируется только при первом обращении к переменной.
  ```kotlin
  val lazyValue: String by lazy {
    println("computed!")
    "Hello"
  }
  ```

- #### Какие существуют модификаторы видимости в Kotlin?
  Kotlin предоставляет четыре модификатора видимости: `private`, `protected`, `internal`, и `public` (по умолчанию). `private` ограничивает видимость областью объявления, `protected` также как `private`, но видимо в подклассах, `internal` видимо в пределах одного модуля, `public` видимо везде.

- #### Что является эквивалентом статических методов Java в Kotlin?
  В Kotlin нет прямого эквивалента статических методов Java, но можно использовать `companion object` или объектные объявления (object) для создания функций, доступных без экземпляра класса.

- #### Что такое data класс в Kotlin?
  Data классы в Kotlin автоматически генерируют методы `equals()`, `hashCode()`, `toString()`, а также `componentN()` для каждого свойства и `copy()`. Они идеально подходят для классов, которые служат для хранения данных.

- #### Как создать Singleton класс в Kotlin?
  Для создания синглтона в Kotlin используется `object`.

- #### Как под капотом работает object в Kotlin?

- #### Как под капотом работает companion object в Kotlin?

- #### Как под капотом работает extension function в Kotlin?

- #### В чем разница между `open` и `public` в Kotlin?
  `public` - это модификатор доступа, который делает член класса доступным из любого места. `open` указывает, что класс или член класса может быть переопределен в подклассе.

- #### Объясните использование `let`, `run`, `with`, `also`, `apply` в Kotlin.
    - `let` используется для выполнения блока кода с объектом и возвращает результат блока.
    - `run` комбинирует `let` и `with`, выполняя блок кода с объектом и возвращая результат.
    - `with` принимает объект и блок кода, выполняет блок с объектом как контекстом и возвращает результат.
    - `apply` и `also` возвращают объект после выполнения блока кода, что удобно для инициализации.

- #### Разница между типами `List` и `Array` в Kotlin
  `Array` - это изменяемая коллекция фиксированного размера, в то время как `List` может быть неизменяемой (`listOf`) или изменяемой (`mutableListOf`), и размер ее может меняться.

- #### Что такое `Labels` в Kotlin?
  Метки позволяют управлять потоком выполнения, особенно во вложенных циклах или при использовании лямбд.
  ```kotlin
  loop@ for (i in 1..100) {
    for (j in 1..100) {
        if (i + j > 100) break@loop
    }
  }
  ```

- #### Что такое Корутины в Kotlin?
  Корутины - это легковесные потоки, позволяющие асинхронно выполнять длительные операции, не блокируя основной поток.

- #### Что такое `Coroutine Scope`?
  `Coroutine Scope` определяет область видимости корутины, управляя ее жизненным циклом.

- #### Что такое `Coroutine Context`?
  `Coroutine Context` содержит настройки корутины, такие как диспетчер, который определяет, в каком потоке будет выполняться корутина.

- #### `Launch` vs `Async` в Kotlin Корутинах
  `launch` запускает корутину без возвращения результата и возвращает `Job`, в то время как `async` запускает корутину, которая возвращает результат в виде `Deferred<T>`.

- #### Когда использовать запечатанные классы (sealed classes) Kotlin?
  `Sealed class` - это специальный класс, который ограничивает иерархию наследования. Все подклассы `sealed class` должны быть объявлены в том же файле, что и сам sealed class. Это позволяет использовать `sealed classes` в качестве выразительного средства для представления ограниченного набора типов и обеспечивает большую безопасность при использовании в `when` выражениях, так как компилятор может проверить, обработаны ли все случаи.
  ```kotlin
  // В файле A.kt
  sealed class MySealedClass

  // В файле B.kt, попытка наследования приведет к ошибке
  class MySubclass : MySealedClass() // Это вызовет ошибку компиляции, так как MySubclass находится в другом файле
  ```

- #### Зачем были созданы sealed классы, если есть enum классы?
    - **Большая гибкость**: Sealed классы позволяют определять различные свойства и методы для каждого подкласса, в то время как enum константы ограничены теми свойствами и методами, которые определены в самом enum классе.
    - **Иерархия типов**: Sealed классы позволяют создавать сложные иерархии типов с различным поведением, что невозможно с enum классами.
    - **Поддержка состояний с данными**: Подклассы sealed класса могут иметь свои собственные конструкторы с параметрами, что позволяет хранить данные в каждом состоянии. В enum классах данные могут быть только фиксированными и общими для всех констант.


- #### Расскажите о Collections в Kotlin
  Kotlin предоставляет множество стандартных коллекций, таких как списки (`List`), множества (`Set`), карты (`Map`), как изменяемые, так и неизменяемые версии.

- #### Extension функции
  Расширяющие функции позволяют добавлять новые функции к существующим классам без их модификации.
  ```kotlin
  fun String.addExclamation(): String = "$this!"
  ```
- #### Что делает ?: в Kotlin? (Оператор Элвиса)
  Elvis оператор используется для предоставления альтернативного значения в случае, если выражение слева от него равно `null`.
  ```kotlin
  val name = getName() ?: "Unknown"
  ```
- #### Что такое делегаты?
    - **Делегирование свойств**: Kotlin позволяет делегировать реализацию операций чтения и записи свойства другому объекту. Это делается с помощью ключевого слова by.
    - **Делегирование реализации интерфейса**: Если класс должен реализовать интерфейс, Kotlin позволяет делегировать реализацию всех методов этого интерфейса другому объекту.
      <br/>

  ```kotlin
  import kotlin.reflect.KProperty

  class Delegate {
      operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
          return "$thisRef, спасибо за делегирование '${property.name}' мне!"
      }
  
      operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
          println("$value было присвоено значению '${property.name}' в $thisRef.")
      }
  }
  
  class Example {
      var p: String by Delegate()
  }
  
  fun main() {
      val e = Example()
      println(e.p) // Чтение из свойства p
      e.p = "Новое значение" // Запись в свойство p
  }
  ```
<br/>

  ```kotlin
  interface SoundBehavior {
      fun makeSound()
  }

  class ScreamBehavior(val n: Int) : SoundBehavior {
      override fun makeSound() {
          repeat(n) {
              println("Aaa!")
          }
      }
  }
  
  class SingBehavior(val song: String) : SoundBehavior {
      override fun makeSound() {
          println("Singing $song")
      }
  }
  
  class Animal(soundBehavior: SoundBehavior) : SoundBehavior by soundBehavior
  
  fun main() {
      val screamer = Animal(ScreamBehavior(3))
      screamer.makeSound()  // Выводит "Aaa!" три раза
  
      val singer = Animal(SingBehavior("Happy Birthday"))
      singer.makeSound()  // Выводит "Singing Happy Birthday"
  }
  ```

- #### nothing vs unit vs any
    - `Nothing` — специальный тип в Kotlin, который не имеет значений. Он используется для обозначения операций, которые никогда не завершаются (например, бесконечный цикл или исключение). Функция, возвращающая Nothing, указывает, что она никогда не вернет управление (то есть всегда прервет выполнение, выбросив исключение)
    - `Unit` в Kotlin аналогичен void в Java. Он используется, когда функция не возвращает значимого результата. Функции, возвращающие Unit, могут возвращать результат явно или не возвращать его вовсе, поскольку Unit — это единственный (синглтон) объект.
    - `Any` — это корневой тип для всех не-nullable типов в Kotlin, аналогично Object в Java. Он используется, когда нужно принять или вернуть любой объект, кроме null.

- #### Какие бывают исключения?
    - **Проверяемые (Checked exceptions)**: Исключения, которые должны быть явно перехвачены или объявлены в сигнатуре метода (только в Java).
    - **Непроверяемые (Unchecked exceptions)**: Исключения, которые могут возникать во время выполнения программы и не требуют обязательного перехвата (в Java и Kotlin).
- #### Сколько инстансов Unit и Nothing мы можем создать в приложении?
    - **Unit** - 1, потому что Singleton.
    - **Nothing** - 0, потому что приватный конструктор.
- #### В чем разница между исключениями в Kotlin и Java?
  В Kotlin все исключения являются непроверяемыми (unchecked), в отличие от Java, где существуют проверяемые (checked) и непроверяемые исключения. Kotlin не требует обязательного указания исключений в сигнатуре метода или оборачивания вызова в блок try-catch.
