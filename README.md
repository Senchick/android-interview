# Android Interview
_Источники [Android Interview Questions](https://github.com/amitshekhariitbhu/android-interview-questions) и [Mobile System Design Interview](https://github.com/iartr/mobile-system-design)_

> ### Disclaimer
> Этот репозиторий написан в первую очередь автором для самообразования и подготовку к собеседованиям. Если Вы найдёте какой-то недочёт в ответах, то можете сообщить об этом.

## Оглавление

* [Kotlin](#kotlin)
* [Kotlin Coroutines](#kotlin-coroutines)
* [Kotlin Flow API](#kotlin-flow-api)
* [Android](#android)
* [Jetpack Compose](#jetpack-compose)
* [Android Библиотеки](#android-библиотеки)
* [Android Архитектура](#android-архитектура)
* [Android System Design](#android-system-design)
* [Android Unit Тестирование](#android-unit-тестирование)
* [Android Инструменты и Технологии](#android-инструменты-и-технологии)
* [Java](#java)
* [Прочие темы](#прочие-темы)
* [Структуры данных и алгоритмы](#структуры-данных-и-алгоритмы)




### Kotlin
- #### Каково преимущество использования `const` в Kotlin?
  `const` используется для определения компиляционных констант. Значения, объявленные как const, встраиваются непосредственно в код в места их использования, что улучшает производительность и уменьшает количество объектов во время выполнения.

- #### Когда использовать ключевое слово `lateinit` в Kotlin?
  `lateinit` используется для отложенной инициализации переменных, тип которых не может быть null. Это позволяет объявить переменную без начальной инициализации и инициализировать ее позже.

- #### Что такое inline функция в Kotlin?
  `Inline` функции встраивают код функции в место ее вызова, что уменьшает накладные расходы на вызов функций, особенно полезно для функций с лямбда-параметрами.

- #### Что такое companion object в Kotlin?
  `Companion object` позволяет объявить члены класса, доступные без создания экземпляра этого класса, аналогично статическим членам в Java.

- #### Удаление дубликатов из массива в Kotlin
  Для удаления дубликатов можно использовать distinct() или преобразовать массив в Set.

- #### Что такое аннотация `JvmStatic` в Kotlin?
  `@JvmStatic` используется в companion object для указания, что аннотированный член должен быть сгенерирован как статический метод в Java.

- #### Что такое аннотация `JvmField` в Kotlin?
  `@JvmField` предотвращает генерацию геттеров и сеттеров для переменной, делая ее публичным полем в Java.

- #### Что такое аннотация `JvmOverloads` в Kotlin?
  `@JvmOverloads` генерирует перегруженные версии функций для Java, предоставляя значения по умолчанию для параметров.

- #### `noinline` в Kotlin
  noinline используется для указания, что лямбда-параметр не должен инлайниться, например, если он передается в другую функцию как аргумент или сохраняется в переменной.
  ```kotlin
  inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) { }
  ```
- #### `crossinline` в Kotlin
  `crossinline` гарантирует, что лямбда-выражение не будет содержать нелокальных возвратов, то есть возвратов из внешней функции.
  ```kotlin
  inline fun withoutCrossinline(block: () -> Unit) {
    println("Before block")
    block() // Этот блок может содержать нелокальный return
    println("After block") // Этот код может быть пропущен, если в block() есть нелокальный return
  }

  inline fun withCrossinline(crossinline block: () -> Unit) {
    println("Before block")
    block() // Этот блок не может содержать нелокальный return из-за crossinline
    println("After block") // Этот код будет выполнен после block() независимо от содержимого block
  }

  fun main() {
    withoutCrossinline {
        println("Inside block")
        return // Нелокальный возврат: выходит из main(), не достигая "After block"
    }
    
    withCrossinline {
      println("Inside block")
      // return // Ошибка: нелокальные возвраты запрещены в лямбде с crossinline
    }
  }
  ```
- #### Функции области видимости в Kotlin
  Функции области видимости (`let`, `run`, `with`, `apply`, `also`) позволяют упростить работу с объектами, временно изменяя их контекст или обеспечивая дополнительную область видимости для выполнения кода.

- #### Что такое ключевое слово `reified` в Kotlin?
  `reified` используется с `inline` функциями для сохранения типов во время выполнения, позволяя работать с ними как с обычными классами, не теряя информацию о типе.
  ```kotlin
  inline fun <T> myGenericFunction(clazz: Class<T>, item: Any) {
    if (item is T) { // Ошибка: Cannot check for instance of erased type: T
        println("Item is of type T")
    }
  }
  
  inline fun <reified T> myGenericFunction(item: Any) {
    if (item is T) { // Теперь это работает, так как T является reified типом
        println("Item is of type T")
    }
  }
  ```

- #### `lateinit` против `lazy` в Kotlin
  lateinit используется для отложенной инициализации мутабельных переменных, а lazy - для иммутабельных переменных, инициализируемых при первом обращении.

- #### Что такое блок `init` в Kotlin?
  Инициализационный блок init используется для выполнения кода в момент создания экземпляра класса.

- #### Разница между `==` и `===` в Kotlin
  `==` проверяет равенство значений, в то время как `===` проверяет идентичность объектов (ссылаются ли переменные на один и тот же объект в памяти).

- #### Что такое функции высшего порядка в Kotlin?
  Функции высшего порядка - это функции, которые принимают функции в качестве параметров или возвращают их. Это позволяет создавать выразительный и гибкий код.

- #### Что такое Лямбды в Kotlin?
  Лямбда-выражения или лямбды - это короткие блоки кода, которые могут быть переданы в функции высшего порядка.

- #### `AssociateBy` - List to Map в Kotlin
  `associateBy` - это функция коллекций, которая создает `Map` из `List`, используя предоставленную функцию для определения ключей.

- #### Ключевое слово `Open` в Kotlin
  В Kotlin все классы по умолчанию закрыты (`final`) для наследования. Чтобы класс мог быть унаследован, он должен быть помечен как `open`.

- #### Модификатор видимости `internal` в Kotlin
  `internal` делает член класса видимым только внутри модуля, в котором он объявлен.

- #### `partition` - функция фильтрации в Kotlin
  `partition` разделяет коллекцию на пару списков по условию: один для элементов, соответствующих условию, и один для остальных.
  ```kotlin
  val (positives, negatives) = list.partition { it > 0 }
  ```

- #### `infix` в Kotlin
  `infix` позволяет вызывать функции с одним параметром без скобок и точки.
  ```kotlin
  infix fun Int.add(other: Int): Int = this + other
  val sum = 1 add 2
  ```

- #### Как работает Kotlin Multiplatform?
  Kotlin Multiplatform - это фреймворк, позволяющий разрабатывать кросс-платформенные приложения, используя Kotlin. Код, не зависящий от платформы, пишется один раз и может быть использован на разных платформах.

- #### Приостанавливающие vs Блокирующие функции в Kotlin Coroutines
  - Приостанавливающие функции (`suspend`) позволяют асинхронно выполнять длительные операции без блокирования потока.
  - Блокирующие операции заставляют поток ожидать завершения операции.

- #### Расскажите некоторые преимущества Kotlin.
  Kotlin предлагает безопасность по отношению к null, сокращенный и более читаемый синтаксис по сравнению с Java, поддержку функционального программирования, совместимость с Java, поддержку корутин для асинхронного программирования.

- #### В чем разница между `val` и `var`?
  `val` объявляет иммутабельную переменную (константу), значение которой не может быть изменено после инициализации. `var` объявляет мутабельную переменную, значение которой может быть изменено.

- #### Как проверить, инициализирована ли переменная `lateinit`?
  ```kotlin
  if (::name.isInitialized) {
    println(name)
  }
  ```

- #### Как выполнить ленивую инициализацию переменных в Kotlin?
  `lazy` предоставляет механизм ленивой инициализации для `val`, когда значение инициализируется только при первом обращении к переменной.
  ```kotlin
  val lazyValue: String by lazy {
    println("computed!")
    "Hello"
  }
  ```

- #### Какие существуют модификаторы видимости в Kotlin?
  Kotlin предоставляет четыре модификатора видимости: `private`, `protected`, `internal`, и `public` (по умолчанию). `private` ограничивает видимость областью объявления, `protected` также как `private`, но видимо в подклассах, `internal` видимо в пределах одного модуля, `public` видимо везде.

- #### Что является эквивалентом статических методов Java в Kotlin?
  В Kotlin нет прямого эквивалента статических методов Java, но можно использовать `companion object` или объектные объявления (object) для создания функций, доступных без экземпляра класса.

- #### Что такое data класс в Kotlin?
  Data классы в Kotlin автоматически генерируют методы `equals()`, `hashCode()`, `toString()`, а также `componentN()` для каждого свойства и `copy()`. Они идеально подходят для классов, которые служат для хранения данных.

- #### Как создать Singleton класс в Kotlin?
  Для создания синглтона в Kotlin используется `object`.

- #### В чем разница между `open` и `public` в Kotlin?
  `public` - это модификатор доступа, который делает член класса доступным из любого места. `open` указывает, что класс или член класса может быть переопределен в подклассе.

- #### Объясните использование `let`, `run`, `with`, `also`, `apply` в Kotlin.
  - `let` используется для выполнения блока кода с объектом и возвращает результат блока.
  - `run` комбинирует `let` и `with`, выполняя блок кода с объектом и возвращая результат.
  - `with` принимает объект и блок кода, выполняет блок с объектом как контекстом и возвращает результат.
  - `apply` и `also` возвращают объект после выполнения блока кода, что удобно для инициализации.

- #### Разница между типами `List` и `Array` в Kotlin
  `Array` - это изменяемая коллекция фиксированного размера, в то время как `List` может быть неизменяемой (`listOf`) или изменяемой (`mutableListOf`), и размер ее может меняться.

- #### Что такое `Labels` в Kotlin?
  Метки позволяют управлять потоком выполнения, особенно во вложенных циклах или при использовании лямбд.
  ```kotlin
  loop@ for (i in 1..100) {
    for (j in 1..100) {
        if (i + j > 100) break@loop
    }
  }
  ```

- #### Что такое Корутины в Kotlin?
  Корутины - это легковесные потоки, позволяющие асинхронно выполнять длительные операции, не блокируя основной поток.

- #### Что такое `Coroutine Scope`?
  `Coroutine Scope` определяет область видимости корутины, управляя ее жизненным циклом.

- #### Что такое `Coroutine Context`?
  `Coroutine Context` содержит настройки корутины, такие как диспетчер, который определяет, в каком потоке будет выполняться корутина.

- #### `Launch` vs `Async` в Kotlin Корутинах
  `launch` запускает корутину без возвращения результата и возвращает `Job`, в то время как `async` запускает корутину, которая возвращает результат в виде `Deferred<T>`.

- #### Когда использовать запечатанные классы (sealed classes) Kotlin?
  `Sealed class` - это специальный класс, который ограничивает иерархию наследования. Все подклассы `sealed class` должны быть объявлены в том же файле, что и сам sealed class. Это позволяет использовать `sealed classes` в качестве выразительного средства для представления ограниченного набора типов и обеспечивает большую безопасность при использовании в `when` выражениях, так как компилятор может проверить, обработаны ли все случаи.
  ```kotlin
  // В файле A.kt
  sealed class MySealedClass

  // В файле B.kt, попытка наследования приведет к ошибке
  class MySubclass : MySealedClass() // Это вызовет ошибку компиляции, так как MySubclass находится в другом файле
  ```
- #### Расскажите о Collections в Kotlin
  Kotlin предоставляет множество стандартных коллекций, таких как списки (`List`), множества (`Set`), карты (`Map`), как изменяемые, так и неизменяемые версии.

- #### Extension функции
  Расширяющие функции позволяют добавлять новые функции к существующим классам без их модификации.
  ```kotlin
  fun String.addExclamation(): String = "$this!"
  ```
- #### Что делает ?: в Kotlin? (Оператор Элвиса)
  Elvis оператор используется для предоставления альтернативного значения в случае, если выражение слева от него равно `null`.
  ```kotlin
  val name = getName() ?: "Unknown"
  ```

### Kotlin Coroutines

- #### корутины


- #### `suspend`


- #### `launch`, `async-await`, `withContext`


- #### диспетчеры


- #### `coroutineScope`, `coroutineContext`, `job`


- #### `lifecycleScope`, `viewModelScope`, `GlobalScope`


- #### `suspendCoroutine`, `suspendCancellableCoroutine`


- #### `coroutineScope`, `supervisorScope`



### Kotlin Flow API

- #### Flow Builder, Operator, Collector


- #### `flowOn`, диспетчеры


- #### Операторы, такие как `filter`, `map`, `zip`, `flatMapConcat`, `retry`, `debounce`, `distinctUntilChanged`, `flatMapLatest`


- #### Терминальные операторы


- #### Cold Flow против Hot Flow


- #### `StateFlow`, `SharedFlow`, `callbackFlow`, `channelFlow`


### Android
#### *База*
- #### Почему возникают лаги в Android приложении?
  - **Неэффективное использование ресурсов:** Неправильное управление памятью, чрезмерное использование CPU или неправильное использование сетевых запросов может замедлить приложение.
  - **Проблемы с пользовательским интерфейсом:** Сложные или плохо оптимизированные анимации и интерфейс могут вызывать задержки в отклике.
  - **Выполнение тяжелых операций в главном потоке:** Выполнение длительных операций, таких как доступ к базе данных или сетевые запросы, в главном потоке UI может привести к "зависанию" приложения.
  - **Утечки памяти:** Утечки памяти происходят, когда объекты не освобождаются после использования, что со временем может привести к истощению доступной памяти и замедлению приложения.

- #### Что такое `Context`? Зачем он используется?
  `Context` в Android — это интерфейс, который предоставляет доступ к глобальной информации о приложении. Он используется для получения доступа к ресурсам, файловым системам, вызова активностей и служб. 
  Существует три типа контекста: `ApplicationContext`, `ActivityContext`, `BaseContext`. 
  1. `ApplicationContext` связан с жизненным циклом приложения
  2. `ActivityContext` связан с жизненным циклом активности. 
  3. `BaseContext` в Android является базовым классом контекста (`Context`). Он используется как родительский класс для `ActivityContext` и `ApplicationContext`, предоставляя основные функции контекста, которые могут быть расширены или использованы в этих специализированных контекстах. `BaseContext` обеспечивает доступ к ресурсам и системным службам, таким как запуск активностей, взаимодействие с различными сервисами Android и управление ресурсами приложения. В контексте Android разработки, когда говорят о `BaseContext`, чаще всего имеют в виду фундаментальную функциональность контекста, на которой основаны все другие типы контекстов.

  Context необходим для:
  1. Доступа к базовым функциям приложения, таким как доступ к ресурсам, базам данных и настройкам. 
  2. Запуска других компонентов, таких как активности и службы.
  3. Взаимодействия с другими приложениями.

- #### Назови все основные компоненты Android приложения? (4)
  Основные компоненты Android приложения включают:
  1. **Activity** - Компонент, который представляет один экран с пользовательским интерфейсом.
  2. **Service** - Компонент для выполнения долгосрочных операций в фоновом режиме.
  3. **Broadcast Receiver** - Компонент, который позволяет приложению получать и реагировать на широковещательные сообщения от других приложений или системы.
  4. **Content Provider** - Компонент для управления доступом к набору данных приложения.

- #### Что такое AndroidManifest.xml?

  `AndroidManifest.xml` — это файл в Android приложении, который содержит важную информацию о приложении для Android системы. Он объявляет конфигурацию приложения, включая его компоненты (активности, службы, получатели широковещательных сообщений, поставщики контента), требуемые разрешения, минимальный уровень API Android, используемый приложением, и другие настройки. `AndroidManifest.xml` читается системой при установке приложения, и на основе этой информации система знает, как взаимодействовать с приложением.

- #### Что такое Application класс?

  Класс `Application` в Android представляет собой базовый класс приложения, который содержит глобальное состояние приложения. Он выполняется до того, как любой другой код приложения будет запущен, и именно здесь можно инициализировать глобальные ресурсы. Класс `Application` можно использовать для выполнения действий и настройки компонентов, которые должны быть доступны во всем приложении, например, инициализации библиотек, настройки управления сессиями или предоставления контекста для использования в других компонентах приложения.



#### *Activity и Fragment*

- #### Почему рекомендуется использовать только конструктор по умолчанию для создания `Fragment`?
  При восстановлении системой фрагментов (например, при пересоздании активности после изменения конфигурации) используется конструктор без параметров. Если вы создадите фрагмент с конструктором с параметрами и не сохраните эти параметры в onSaveInstanceState, вы можете потерять эти данные при пересоздании фрагмента, что приведет к ошибкам или непредвиденному поведению.

- #### Что такое `Activity` и его жизненный цикл?
  Activity - это компонент приложения, предоставляющий экран с пользовательским интерфейсом. Жизненный цикл Activity включает методы: onCreate(), onStart(), onResume(), onPause(), onStop(), onRestart(), onDestroy().

  - **onCreate()** вызывается при первом создании активности. Здесь происходит инициализация.
  - **onStart()** вызывается, когда активность становится видимой пользователю.
  - **onResume()** вызывается, когда активность вступает в фокус и готова к взаимодействию с пользователем.
  - **onPause()** вызывается при переходе активности в состояние "пауза", когда она все еще видима, но уже не в фокусе.
  - **onStop()** вызывается, когда активность больше не видна пользователю.
  - **onRestart()** вызывается после того, как активность была остановлена и снова была запущена пользователем.
  - **onDestroy()** вызывается перед тем, как активность будет уничтожена.

- #### В чем разница между `onCreate()` и `onStart()`?
  Это может произойти в крайне редких случаях, например, если система уничтожает процесс приложения для освобождения ресурсов в условиях нехватки памяти. В обычной ситуации onPause() и onStop() всегда вызываются перед onDestroy().

- #### Когда вызывается только `onDestroy` для `Activity` без `onPause()` и `onStop()`?
  Это может произойти в крайне редких случаях, например, если система уничтожает процесс приложения для освобождения ресурсов в условиях нехватки памяти. В обычной ситуации onPause() и onStop() всегда вызываются перед onDestroy().

- #### Почему нам нужно вызывать `setContentView()` в `onCreate()` класса `Activity`?
  setContentView() устанавливает макет пользовательского интерфейса для активности и должен быть вызван в onCreate(), чтобы до начала взаимодействия с пользователем активность имела загруженный и готовый интерфейс.

- #### Что такое `onSaveInstanceState()` и `onRestoreInstanceState()` в `Activity`?
    - `onSaveInstanceState()` - Этот метод используется для сохранения данных перед паузой `Activity`.
    - `onRestoreInstanceState()` - Этот метод используется для восстановления сохраненного состояния `Activity`, когда `Activity` пересоздается после уничтожения. Таким образом, `onRestoreInstanceState()` получает пакет, который содержит информацию о состоянии экземпляра.

- #### Что такое `Fragment` и его жизненный цикл?
  `Fragment` – это компонент приложения, который имеет свой жизненный цикл, получает события ввода и может быть добавлен в активность. Жизненный цикл фрагмента включает такие методы, как onAttach(), onCreate(), onCreateView(), onActivityCreated(), onStart(), onResume(), onPause(), onStop(), onDestroyView(), onDestroy(), onDetach():
  - **onAttach()** - вызывается, когда фрагмент связывается с активностью.
  - **onCreate()** - система вызывает этот метод, когда создает фрагмент. Создайте здесь компоненты, которые необходимы вне видимости пользователя.
  - **onCreateView()** - вызывается для создания макета фрагмента. В этом методе вы должны создать и вернуть макет фрагмента.
  - **onActivityCreated()** - вызывается, когда активность, к которой прикреплен фрагмент, завершила свой метод onCreate().
  - **onStart()** - вызывается, когда фрагмент становится видимым.
  - **onResume()** - вызывается, когда фрагмент получает фокус и может взаимодействовать с пользователем.
  - **onPause()** - вызывается, когда пользователь теряет фокус на фрагменте, и можно сохранить изменения или обновления.
  - **onStop()** - вызывается, когда фрагмент больше не видим.
  - **onDestroyView()** - вызывается при удалении макета фрагмента.
  - **onDestroy()** - вызывается при уничтожении фрагмента.
  - **onDetach()** - вызывается, когда фрагмент отсоединяется от активности.

- #### Что такое "launchMode"? и `singleTask` launchMode в `Android`?
  launchMode определяет, как активность будет вставлена в стек задач. singleTask – это режим запуска, при котором в стеке задач может быть только один экземпляр активности. Если активность уже находится в стеке, система очищает все активности, находящиеся над ней, и передает интент этой активности через onNewIntent().

- #### В чем разница между `Fragment` и `Activity`? Объясните взаимосвязь между ними.
  Activity действует как контейнер для пользовательского интерфейса и управляет взаимодействием пользователя с экраном. Fragment, с другой стороны, представляет собой повторно используемую часть пользовательского интерфейса с собственным жизненным циклом, которая может быть встроена в активность. Фрагменты добавляют гибкость в проектирование интерфейса, позволяя активности включать несколько фрагментов на одном экране и переиспользовать фрагмент в разных активностях.

- #### Когда следует использовать `Fragment` вместо `Activity`?
  - Когда у вас есть некоторые компоненты пользовательского интерфейса, которые должны использоваться в различных `Activity`
  - Когда несколько представлений могут быть отображены бок о бок, как например `ViewPager`

- #### В чем разница между `FragmentPagerAdapter` и `FragmentStatePagerAdapter`?
  - `FragmentPagerAdapter`: Каждый `Fragment`, посещенный пользователем, будет храниться в памяти, но представление будет уничтожено. Когда страница снова посещается, то создается представление, а не экземпляр фрагмента.
  - `FragmentStatePagerAdapter`: Здесь экземпляр фрагмента будет уничтожен, когда он не виден пользователю, за исключением сохраненного состояния фрагмента.

- #### В чем разница между добавлением/заменой фрагмента в backstack?
  При добавлении фрагмента, он размещается поверх предыдущего, не удаляя его, в то время как замена удаляет текущий фрагмент и добавляет новый. Использование addToBackStack() позволяет возвращаться к предыдущему фрагменту с помощью кнопки "Назад".

- #### Как осуществляется коммуникация между двумя `Fragments`?
  - Через ViewModel
  - Через Activity

- #### Что такое retained `Fragment`?
  По умолчанию, `Fragments` уничтожаются и пересоздаются вместе с их родительскими `Activities` при изменении конфигурации. Вызов `setRetainInstance(true)` позволяет нам обойти этот цикл уничтожения и пересоздания, сигнализируя системе о сохранении текущего экземпляра фрагмента, когда `Activity` пересоздается.

- #### Какова цель `addToBackStack()` при выполнении транзакции фрагмента?
  При вызове `addToBackStack()`, транзакция замены сохраняется в стеке возврата, так что пользователь может отменить транзакцию и вернуть предыдущий фрагмент, нажав кнопку Назад.



#### *Views и ViewGroups*
- #### Что такое View в `Android`?
  `View` объекты являются основными строительными блоками элементов пользовательского интерфейса (UI) в `Android`. View это простая прямоугольная коробка, которая реагирует на действия пользователя. Примеры включают `EditText`, `Button`, `CheckBox` и т. д. View относится к классу `android.view.View`, который является базовым классом всех классов UI.

- #### Разница между `View.GONE` и `View.INVISIBLE`?


- #### Можете ли вы создать пользовательский View? Как?


- #### Что такое ViewGroup и чем они отличаются от View?
  - `View`: объекты View являются основными строительными блоками элементов пользовательского интерфейса (UI) в `Android`. View это простая прямоугольная коробка, которая реагирует на действия пользователя. Примеры включают `EditText`, `Button`, `CheckBox` и т. д. View относится к классу `android.view.View`, который является базовым классом всех классов UI.
  - `ViewGroup`: ViewGroup это невидимый контейнер. Он содержит View и ViewGroup. Например, `LinearLayout` это ViewGroup, который содержит `Button`(View), и другие компоновки также. ViewGroup является базовым классом для компоновок.

- #### Что такое Canvas?


- #### Что такое SurfaceView?


- #### Relative Layout против Linear Layout.


- #### Расскажите о Constraint Layout

- #### Знаете ли вы, что такое дерево View? Как можно оптимизировать его глубину?



#### *Отображение списков контента*

- #### Чем отличается `ListView` от `RecyclerView`?


- #### Как внутренне работает `RecyclerView`?


- #### Оптимизация `RecyclerView` - Улучшение производительности прокрутки


- #### Оптимизация вложенного `RecyclerView`


- #### Что такое `SnapHelper`?



#### *Диалоги и Toast*

- #### Что такое `Dialog` в `Android`?


- #### Что такое `Toast` в `Android`?


- #### В чем разница между `Dialog` и `DialogFragment`?



#### *Intents и Broadcasts*


- #### Что такое `Intent`?


- #### Что такое неявный `Intent`?


- #### Что такое явный `Intent`?


- #### Что такое `BroadcastReceiver`?


- #### Что такое липкий `Intent` (`Sticky Intent`)?


- #### Опишите, как работают `Broadcasts` и `intents`, чтобы передавать сообщения по вашему приложению?


- #### Что такое `PendingIntent`?


- #### Какие существуют различные типы `Broadcasts`?



#### *Services*

- #### Что такое `Service`?


- #### `Service` против `IntentService`


- #### Что такое сервис переднего плана (`Foreground Service`)?


- #### Что такое `JobScheduler`?



#### *Межпроцессорное взаимодействие*

- #### Как могут взаимодействовать два разных приложения `Android`?


- #### Возможно ли запускать приложение `Android` в нескольких процессах? Как?


- #### Что такое AIDL? Перечислите шаги по созданию ограниченного сервиса через AIDL.


- #### Что можно использовать для фоновой обработки в `Android`?


- #### Что такое `ContentProvider` и для чего он обычно используется?


#### *Длительные операции*

- #### Как выполнить параллельные задачи и получить обратный вызов, когда все они завершены?


- #### Что такое ANR? Как можно предотвратить ANR?


- #### Что такое `AsyncTask` (Устарел в API уровня 30)?


- #### Какие проблемы у `AsyncTask`?


- #### Объясните `Looper`, `Handler` и `HandlerThread`.


- #### Утечка памяти в `Android` и сборка мусора


#### *Работа с мультимедиа контентом*

- #### Как вы обрабатываете изображения в формате `bitmap` в `Android`, так как они занимают слишком много памяти?

- #### Расскажите о пуле `bitmap`.


#### *Сохранение данных*

- #### Jetpack DataStore Preferences


- #### Как сохранить данные в приложении `Android`?


- #### Что такое ORM? Как это работает?


- #### Как сохранить состояние `Activity` во время поворота экрана?


- #### Какие разные способы хранения данных в вашем приложении `Android`?


- #### Объясните Scoped Storage в `Android`.


- #### Как зашифровать данные в `Android`?


- #### Что такое `commit()` и `apply()` в `SharedPreferences`?

#### *Look and Feel*

- #### Что такое `Spannable`?


- #### Что такое `SpannableString`?


- #### Какие лучшие практики использования текста в `Android`?


- #### Как реализовать темную тему в любом приложении?

#### *Оптимизация памяти*

- #### Что такое метод `onTrimMemory()`?


- #### Как идентифицировать и устранить проблемы с OutOfMemory?


- #### Как найти утечки памяти в приложениях `Android`?

#### *Оптимизация времени работы батареи*

- #### Как снизить потребление батареи в приложении `Android`?


- #### Что такое Doze? Что насчет режима ожидания приложения?


- #### Что такое перерисовка?

#### *Поддержка разных экранов*

- #### Как вы поддерживаете различные типы разрешений экранов?

#### *Разрешения*

- #### Какие разные уровни защиты в разрешениях?

#### *Native программирование*

- #### Что такое NDK и почему он полезен?


- #### Что такое renderscript?


#### *Внутренности Системы Android*

- #### Что такое Android Runtime?


- #### Dalvik, ART, JIT и AOT в `Android`


- #### В чем различия между Dalvik и ART?


- #### Что такое DEX?


- #### Что такое Multidex в `Android`?


- #### Можно ли вручную вызвать сборщик мусора?



#### *Android Jetpack*


- #### Что такое Android Jetpack и зачем его использовать?


- #### Что такое `ViewModel` и в чем его польза? Учиться: Что такое `ViewModel` и в чем его польза?


- #### Что такое компоненты архитектуры `Android`?


- #### Что такое `LiveData` в `Android`?


- #### Чем `LiveData` отличается от `ObservableField`?


- #### В чем разница между `setValue` и `postValue` в `LiveData`?


- #### Как поделиться `ViewModel` между фрагментами в `Android`?


- #### Объясните `WorkManager` и его случаи использования.


- #### Как внутренне работает `ViewModel`?

#### *Прочее*

- #### Почему класс `Bundle` используется для передачи данных и почему мы не можем использовать простую структуру данных Map?


- #### Как вы устраняете сбои приложения?


- #### Объясните как работает система уведомлений `Android`. 


- #### В чем разница между `Serializable` и `Parcelable`? Какой подход лучше в `Android`?


- #### Что такое AAPT?


- #### FlatBuffers vs JSON.


- #### `HashMap`, `ArrayMap` и `SparseArray`


- #### Что такое Аннотации?


- #### Как создать пользовательскую Аннотацию?


- #### Что такое библиотека поддержки? Почему она была введена?


- #### Что такое привязка данных в `Android`?

### Jetpack Compose

### Android Библиотеки

- #### Объясните `OkHttp Interceptor`
  `OkHttp Interceptor` позволяет перехватывать и модифицировать запросы и ответы перед и после их отправки/получения соответственно. Это может быть полезно для добавления, удаления или изменения заголовков запросов и ответов, логирования запросов/ответов, управления кэшированием и т.д.

- #### `OkHttp` - HTTP Кэширование


- #### Почему мы используем фреймворк внедрения зависимостей, например `Dagger`, в `Android`?


- #### Как работает `Dagger`?


- #### Как вы будете выбирать между `Dagger 2` и `Dagger-Hilt`?


- #### Что такое `Component` в `Dagger`?


- #### Что такое `Module` в `Dagger`?


- #### Как работает кастомная область видимости в `Dagger`?


- #### Когда вызывать `dispose` и `clear` на `CompositeDisposable` в `RxJava`?


- #### Что такое Multipart Request в Сетевых запросах?


- #### Что такое `Flow` в Kotlin?


- #### App Startup Library


- #### Расскажите что-нибудь о `RxJava`.


- #### Как вы будете обрабатывать ошибки в `RxJava`?


- #### `FlatMap` против `Map` Оператор


- #### Когда использовать оператор `Create` и когда использовать оператор `fromCallable` в `RxJava`?


- #### Когда использовать оператор `defer` в `RxJava`?


- #### Как используются операторы `Timer`, `Delay` и `Interval` в `RxJava`?


- #### Как сделать два сетевых вызова параллельно с использованием `RxJava`?


- #### Расскажите разницу между `Concat` и `Merge`.


- #### Объясните `Subject` в `RxJava`?


- #### Какие типы `Observables` существуют в `RxJava`?


- #### Как реализовать функцию поиска с использованием `RxJava` в вашем приложении?


- #### Пагинация в `RecyclerView` с использованием операторов `RxJava`


- #### Как работают библиотеки загрузки изображений `Glide` и `Fresco` в `Android`?


- #### Разница между `Schedulers.io()` и `Schedulers.computation()` в `RxJava`.




### Android Архитектура

- #### Архитектура вашего последнего приложения


- #### Описание MVVM
  MVVM (Model-View-ViewModel) - это архитектурный паттерн, используемый в разработке программного обеспечения для упрощения разработки пользовательских интерфейсов. Он разделяет программу на три основных компонента:
  - **Model** (Модель) представляет собой бизнес-логику и данные. Она отвечает за получение, хранение и обработку данных.
  - **View** (Представление) отображает данные (модель) пользователю и отправляет пользовательские команды (например, нажатие кнопки) в ViewModel.
  - **ViewModel** является посредником между View и Model, отвечая за обработку всех логических операций представления, преобразовывая данные модели для представления.

- #### Описание MVI
  MVI (Model-View-Intent) - это архитектурный паттерн, в котором "Intent" обозначает намерение изменить состояние приложения. Этот подход поощряет приложения работать в более реактивном стиле.
  - **Model** хранит состояние приложения.
  - **View** отображает состояние модели пользователю и генерирует "Intents" на основе взаимодействий пользователя.
  - **Intent** представляет намерение изменить состояние и передается в бизнес-логику для обработки.

- #### MVC vs MVP vs MVVM vs MVI архитектура


- #### Чистая Архитектура



### Android System Design

- #### Разработка библиотеки загрузки изображений


- #### Разработка библиотеки загрузки файлов


- #### Разработка WhatsApp


- #### Разработка историй в Instagram


- #### Разработка сетевой библиотеки


- #### Разработка приложения Facebook для поиска друзей поблизости


- #### Разработка библиотеки кэширования


- #### Проблемы дизайна, основанные на приложениях с использованием геолокации


- #### Как построить приложение с offline-first подходом? Объясните архитектуру


- #### Разработка `LRU` кэша


- #### Разработка библиотеки аналитики


- #### HTTP Request vs HTTP Long-Polling vs WebSockets


- #### Как работают голосовые и видеозвонки?


- #### Разработка приложения Uber

### Android Unit Тестирование

- #### Модульное тестирование `ViewModel` с `Kotlin Coroutines` и `LiveData`


- #### Модульное тестирование `ViewModel` с `Kotlin Flow` и `StateFlow`


- #### Что такое `Espresso`?


- #### Что такое `Robolectric`?


- #### Какие недостатки у `Robolectric`?


- #### Что такое `UI-Automator`?


- #### Объясните что такое unit тестирование


- #### Объясните что такое инструментальное тестирование


- #### Почему используется `Mockito`?


- #### Расскажите, что такое code coverage

### Android инструменты и технологии

- #### Что такое `ADB`?


- #### Что такое `StrictMode`?


- #### Что такое `Lint`? Для чего он используется?


- #### `Git`


- #### `Firebase`


- #### Как измерить время выполнения метода в `Android`?


- #### Можно ли получить доступ к вашей базе данных `SQLite` для отладки?


- #### На что нужно обратить внимание при использовании `Proguard`?


- #### Как использовать `Memory Profiler` в `Android Studio`?


- #### Что такое `Gradle`?


- #### Уменьшение размера APK


- #### Как можно ускорить сборку `Gradle`?


- #### Расскажите о системе сборки `Gradle`


- #### Расскажите о создании нескольких APK для приложения `Android`


- #### Для чего используется `Proguard`?


- #### Что такое обфускация? Для чего она используется? Что такое минификация?


- #### Как изменить некоторые параметры в приложении без обновления приложения?


### Java
#### *ООП*
- #### Объясните концепты ООП в `Java`.
  ООП (Объектно-Ориентированное Программирование) в `Java` включает в себя четыре основных концепта:
  - **Инкапсуляция**: Сокрытие внутренней реализации класса и защита его данных.
  - **Наследование**: Создание новых классов на основе существующих.
  - **Полиморфизм**: Возможность использовать объекты с одним интерфейсом без информации о типе и внутренней структуре объекта.
  - **Абстракция**: Отделение концепции от ее экземпляра.


- #### Различия между абстрактными классами и интерфейсами?
  - Абстрактный класс - это класс, который содержит как конкретные, так и абстрактные методы (методы без реализации). Абстрактный метод должен быть реализован подклассами абстрактного класса. Абстрактные классы не могут быть инстанцированы и должны быть расширены для использования.
  - Интерфейс подобен чертежу/контракту класса (или его можно рассматривать как класс с методами, но без их реализации). Он содержит пустые методы, которые представляют, что должно быть общим у всех его подклассов. Подклассы обеспечивают реализацию каждого из этих методов. Интерфейсы реализуются.

- #### Разница между перегрузкой метода и переопределением метода.
  - **Перегрузка метода (Method Overloading)**: Это когда несколько методов в одном классе имеют одно и то же имя, но различаются по типу и/или количеству параметров.
  - **Переопределение метода (Method Overriding)**: Это когда подкласс заменяет метод своего суперкласса.


- #### Какие модификаторы доступа вы знаете? Что делает каждый из них?
  В `Java` существует четыре модификатора доступа (от строжайшего к наиболее либеральному):
  - `private` переменные, методы, конструкторы или внутренние классы видны только внутри своего класса и его методов. Этот модификатор чаще всего используется, например, для доступа к переменным только через геттеры и сеттеры или для скрытия внутренней реализации классов, которые не должны использоваться пользователем, тем самым поддерживая инкапсуляцию. Конструктор Singleton также помечается как private, чтобы избежать нежелательного инстанцирования извне.
  - `Default` (ключевое слово не используется) этот модификатор может быть применен к классам, переменным, конструкторам и методам и позволяет доступ из классов и методов внутри того же пакета.
  - `protected` может использоваться для переменных, методов и конструкторов, тем самым разрешая доступ только подклассам и классам внутри того же пакета, что и класс защищенных членов.
  - `public` модификатор широко используется для классов, переменных, конструкторов и методов для предоставления доступа из любого класса и метода где угодно. Его не следует использовать повсеместно, поскольку это подразумевает, что данные, помеченные как public, не являются чувствительными и не могут быть использованы для нанесения вреда программе.

- #### Может ли интерфейс реализовать другой интерфейс?
  Да, интерфейс может реализовать другой интерфейс (и более одного), но ему нужно использовать ключевое слово `extends`, а не `implements`. И хотя вы не можете удалять методы из родительского интерфейса, вы можете свободно добавлять новые к своему подинтерфейсу.

- #### Что такое Полиморфизм? Что насчет Наследования?
  - **Полиморфизм**: Это способность одного и того же кода вести себя по-разному в зависимости от контекста, в основном достигается через переопределение метода.
  - **Наследование**: Это механизм в `Java`, позволяющий одному классу использовать поля и методы другого класса.
#### *Коллекции и дженерики*

- #### `Arrays` против `ArrayLists`
  - **Arrays**: Простые, фиксированной длины структуры данных для хранения элементов одного типа.
  - **ArrayLists**: Реализация изменяемого массива в `Java`, которая может автоматически увеличиваться и уменьшаться.

- #### `HashSet` против `TreeSet`
  - **HashSet**: Реализация множества, использующая хеш-таблицу для хранения элементов. Не гарантирует порядка элементов.
  - **TreeSet**: Реализация множества, основанная на красно-черном дереве, которая поддерживает упорядоченность элементов по возрастанию.

- #### `HashMap` против `Set`
  - **HashMap**: Коллекция, использующая пары ключ-значение для хранения данных, где каждый ключ уникален.
  - **Set**: Интерфейс, представляющий коллекцию уникальных элементов, не допускающий дублирования.

- #### Объясните дженерики в `Java`.
  Дженерики в `Java` позволяют программистам использовать типы (классы и интерфейсы) в качестве параметров при определении классов, интерфейсов и методов. Они обеспечивают строгую проверку типов во время компиляции и поддерживают обобщенное программирование, что делает код более безопасным и легче читаемым.

#### *Объекты и примитивы*

- #### Как реализован класс `String`? Почему он был сделан неизменяемым?
  В `Java` нет примитивного варианта класса `String` - все строки являются просто обертками вокруг базового массива символов, который объявлен как final. Это означает, что, как только объект `String` создан, он не может быть изменен с помощью обычных инструментов языка (Reflection все еще может ужасно все испортить, потому что в `Java` никакой объект на самом деле не является полностью неизменяемым). Именно поэтому переменные класса `String` являются первыми кандидатами для использования, когда вы хотите переопределить hashCode() и equals() вашего класса - вы можете быть уверены, что все их требуемые контракты будут выполнены.

- #### Что значит сказать, что строка (`String`) неизменяема?
  Это означает, что после создания объекта `String`, его содержимое (массив символов) не может быть изменено. Любые операции, которые кажутся изменяющими строку, на самом деле создают новый объект `String`.



- #### Можете ли вы перечислить 8 примитивных типов в `Java`?
  - `byte`
  - `short`
  - `int`
  - `long`
  - `float`
  - `double`
  - `char`
  - `boolean`

- #### В чем разница между `Integer` и `int`?
  - **int**: примитивный тип данных, представляющий целочисленные значения.
  - **Integer**: класс-обертка, предоставляющий методы для работы с объектами, содержащими целочисленные значения, и позволяющий использовать `int` в качестве объектов.

- #### Передаются ли объекты по ссылке или по значению в `Java`? Раскройте этот вопрос.
  В `Java` все параметры передаются по значению. Для объектов значение ссылки на объект копируется в параметр метода.

- #### Что такое сборщик мусора? Как он работает?
  Сборщик мусора в `Java` автоматически удаляет объекты, на которые больше нет ссылок, тем самым освобождая память для повторного использования. Все объекты размещаются в куче, управляемой JVM. Пока на объект ссылаются, JVM считает его живым. Как только на объект больше не ссылаются и, следовательно, он недоступен для кода приложения, сборщик мусора удаляет его и освобождает неиспользуемую память.

#### *Параллелизм*

- #### Что означает ключевое слово `synchronized`?
  Ключевое слово `synchronized` используется для обозначения методов или блоков кода, которые могут быть выполнены только одним потоком одновременно для предотвращения проблем совместного доступа.

- #### Что такое `ThreadPoolExecutor`?
  `ThreadPoolExecutor` - это реализация пула потоков в `Java`, которая управляет пулом рабочих потоков, позволяя эффективно выполнять множество асинхронных задач.

- #### Что такое модификатор `volatile`?
  Модификатор `volatile` используется для переменных, чтобы гарантировать, что чтение и запись переменной будет производиться непосредственно в основную память, обеспечивая таким образом видимость изменений в разных потоках.

- #### Классы в пакете atomic предоставляют общий набор методов: get, set, lazyset, compareAndSet, и weakCompareAndSet. Пожалуйста, опишите их.
  - **get**: возвращает текущее значение.
  - **set**: устанавливает новое значение.
  - **lazyset**: устанавливает новое значение с гарантией порядка изменений только в однопоточных контекстах.
  - **compareAndSet**: атомарно устанавливает новое значение, если текущее значение соответствует ожидаемому.
  - **weakCompareAndSet**: вариант `compareAndSet` с возможностью неудачи в некоторых ситуациях для улучшения производительности.

#### *Исключения*
- #### Как работают try{}, catch{}, finally{}?
  - **try{}**: блок кода, в котором могут возникнуть исключения.
  - **catch{}**: блок кода, обрабатывающий исключение, возникшее в блоке try.
  - **finally{}**: блок кода, который выполняется после блоков try/catch, независимо от того, возникло исключение или нет.

- #### В чем разница между Проверяемым Исключением и Непроверяемым Исключением?
  - **Проверяемые исключения (Checked Exceptions)**: это исключения, которые должны быть явно перехвачены или объявлены в методе.
  - **Непроверяемые исключения (Unchecked Exceptions)**: это исключения, которые не требуют явного перехвата или объявления в методе.
- 
#### *Другое*
- #### Что такое сериализация? Как вы ее реализуете?
  Сериализация - это процесс преобразования объекта в последовательность битов для сохранения или передачи. В `Java` это можно реализовать с помощью интерфейса `Serializable`.

- #### Что такое модификатор `transient`?
  Модификатор `transient` используется для исключения полей класса при сериализации.

- #### Что такое анонимные классы?
  Анонимные классы - это классы без имени, объявленные и инициализированные одновременно, обычно используются для создания экземпляров простых интерфейсов или классов на месте.

- #### В чем разница между использованием == и .equals на объекте?
  - **==**: проверяет равенство ссылок на объекты.
  - **.equals()**: проверяет равенство содержимого объектов.

- #### Для чего используются hashCode() и equals()?
  Методы `hashCode()` и `equals()` используются для сравнения объектов. `hashCode()` возвращает хеш-код объекта, а `equals()` проверяет, равны ли два объекта.

- #### Когда бы вы придали объекту значение final?
  Ключевое слово `final` используется для объявления констант, переменных, которые не могут быть изменены после инициализации.

- #### Что такое ключевые слова final, finally и finalize?
  - **final**: используется для объявления констант, методов, которые не могут быть переопределены, и классов, которые не могут быть наследованы.
  - **finally**: блок кода, который выполняется после блока try/catch в конструкции обработки исключений, независимо от того, было ли исключение.
  - **finalize()**: метод, вызываемый перед утилизацией объекта сборщиком мусора.

- #### В чем разница между ключевыми словами "throw" и "throws" в `Java`?
  - **throw**: используется для явного выброса исключения.
  - **throws**: указывает на то, что метод может выбросить исключение, и требует его обработки или дальнейшего объявления.

- #### Что означает слово static в `Java`?
  Ключевое слово `static` используется для объявления членов класса, которые могут быть доступны без создания экземпляра класса.

- #### Можно ли переопределить статический метод в `Java`?
  Статические методы не могут быть переопределены в том смысле, как переопределяются обычные методы. Они могут быть "скрыты" в подклассе, если в подклассе объявлен статический метод с тем же именем.

- #### Когда выполняется статический блок?
  Статический блок выполняется при первой загрузке класса в JVM.

- #### Что такое рефлексия?
  Рефлексия в `Java` позволяет программе исследовать или "размышлять" о себе самой, изменять свое поведение во время выполнения.

- #### Что такое Внедрение Зависимостей (DI)?
  Внедрение зависимостей - это дизайн-паттерн, который позволяет классам получать свои зависимости извне, вместо их создания внутри себя, улучшая модульность и тестируемость.

- #### Разница между `StringBuffer` и `StringBuilder`?
  - **StringBuffer**: потокобезопасная версия изменяемой последовательности символов.
  - **StringBuilder**: не потокобезопасная версия, более быстрая по сравнению с `StringBuffer` при выполнении операций в однопоточном режиме.


- #### В чем разница между быстро-сбойными и безопасно-сбойными итераторами в `Java`?
  Быстро-сбойные итераторы немедленно выдают `ConcurrentModificationException`, если коллекция была изменена после создания итератора любым способом, кроме самого итератора. Это предназначено для обнаружения ошибок в многопоточных программах. Безопасно-сбойные итераторы используют механизмы, такие как копирование коллекции, что позволяет итераторам проходить по коллекции без выбрасывания исключения, даже если основная коллекция была изменена во время итерации.

- #### Монитор и Синхронизация
  Монитор в `Java` - это механизм, обеспечивающий возможность синхронизированного доступа к блоку кода или методу, так что в каждый момент времени только один поток может исполнять блок кода или метод, помеченный как `synchronized`. Синхронизация используется для предотвращения проблем совместного доступа и состояния гонки, обеспечивая, чтобы только один поток мог выполнить определенный участок кода, работающий с общими ресурсами, в данный момент времени.







### Прочие темы

### Структуры данных и алгоритмы
  Алгоритмы, которые могут спросить на собеседованиях зачастую берут с LeetCode сложности easy и medium:
  * https://leetcode.com/explore/interview/card/top-interview-questions-easy/
  * https://leetcode.com/explore/interview/card/top-interview-questions-medium/

![Big O Cheat Sheet](/img/big-o-cheat-sheet-poster.png "Big O Cheat Sheet")

```kotlin
fun main(args: Array<String>) {
    println("Hello, world!")
}
```