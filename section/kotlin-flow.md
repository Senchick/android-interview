### Kotlin Flow

- #### Что такое Flow?
  `Flow` в Kotlin – это тип, который может асинхронно предоставлять значения. Он поддерживает асинхронные потоки данных и используется для представления значений, которые могут быть доступны в будущем. `Flow` позволяет управлять асинхронным кодом более удобно и функционально.
- #### Flow vs Coroutines
  В сопрограммах поток — это тип, который может выдавать несколько значений последовательно, в отличие от suspend функций, которые возвращают только одно значение

- #### Flow Builder, Operator, Collector
    - `Flow` создаётся с помощью `builder` функций. Самый базовый builder – это `flow {}`, внутри которого вы можете отправлять значения с помощью `emit()`.
    - `Операторы Flow` позволяют трансформировать, фильтровать, комбинировать и выполнять другие операции с потоками данных. Например, `map` и `filter`.
    - `Collector` – это терминальная операция, которая запускает выполнение flow и обрабатывает каждое значение, отправленное в поток. В примерах выше использовался collect {} как коллектор.
- #### `flowOn`, Dispatchers
  **flowOn** позволяет изменить контекст выполнения операций внутри потока (Flow). Это особенно полезно, когда тяжелые операции должны выполняться в фоновом потоке, а результаты обрабатываться в основном потоке
  ```kotlin
  import kotlinx.coroutines.*
  import kotlinx.coroutines.flow.*

  fun main() = runBlocking {
    flow {
        for (i in 1..3) {
            Thread.sleep(100) // Имитация длительной операции
            emit(i)
        }
    }.flowOn(Dispatchers.Default) // Выполнение в фоновом потоке
    .map { value ->
        "Преобразованное значение $value"
    }
    .collect { value ->
        println("$value на потоке ${Thread.currentThread().name}")
    }
  }
  ```

- #### Операторы, такие как `filter`, `map`, `zip`, `flatMapConcat`, `retry`, `debounce`, `distinctUntilChanged`, `flatMapLatest`
    - **filter**: Отфильтровывает элементы, не соответствующие условию.
    - **map**: Преобразует элементы в другие объекты.
    - **zip**: Комбинирует два потока данных, сопоставляя их элементы.
    - **flatMapConcat**: Преобразует каждый элемент в поток и объединяет эти потоки последовательно.
    - **retry**: Повторяет поток при возникновении ошибки.
    - **debounce**: Эмитирует элементы с задержкой, игнорируя быстро последующие элементы.
    - **distinctUntilChanged**: Пропускает элементы, значение которых отличается от предыдущего.
    - **flatMapLatest**: Аналогично flatMapConcat, но при появлении нового элемента отменяет предыдущий преобразованный поток.

- #### Терминальные операторы
  **Терминальные операторы** - это те, которые запускают выполнение потока и обычно возвращают результат или вызывают сайд-эффекты (например, collect, toList, toSet, first, reduce).
- #### Cold Flow против Hot Flow
    - **Cold Flow**: Не начинает выполнение до вызова терминального оператора, обеспечивая ленивость и удобство создания потоков данных.
    - **Hot Flow**: Активен независимо от наличия подписчиков, подходит для представления данных, которые изменяются во времени (например, пользовательский ввод).

- #### `StateFlow`, `SharedFlow`, `callbackFlow`, `channelFlow`
    - **StateFlow**: Хранит текущее состояние и извещает подписчиков о его изменении. Это Hot Flow. Требуется начальное значение, и он выдает его, как только коллектор начинает собирать данные. Он не выдает последовательные повторяющиеся значения. Он выдает значение только в том случае, если оно отличается от предыдущего элемента.
    - **SharedFlow**: Более общий Hot Flow, который может репрезентировать множество значений и имеет более гибкие настройки. Не требует начального значения, поэтому по умолчанию не выдает никаких значений. Он выдает все значения и не заботится об отличиях от предыдущего элемента. Он также выдает последовательные повторяющиеся значения.
    - **callbackFlow** и **channelFlow**: Позволяют создавать потоки на основе коллбэков или событий, удобно применять для интеграции с API, основанными на коллбэках.

- #### `StateIn`, `SharedIn`
  Эти операторы используются для преобразования Cold Flow в Hot Flow (StateFlow или SharedFlow соответственно), делая поток активным и позволяя сохранять текущее состояние или делиться им сразу с несколькими подписчиками.
